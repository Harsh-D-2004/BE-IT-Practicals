doc1.txt
apple 2
banana 1

doc2.txt
banana 3
grape 1

doc3.txt
grape 2
orange 1

doc4.txt
apple 3
banana 2
lemon 1


Code : 


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

class SinglePassAlgorithm {

    public static void main(String[] args) throws IOException {

        final int noOfDocs = 4;

        String[] fileNames = {"doc1.txt", "doc2.txt", "doc3.txt", "doc4.txt"};

        Set<String> vocabSet = new HashSet<>();
        List<Map<String, Integer>> allDocWordCounts = new ArrayList<>();

        for (String fileName : fileNames) {
            Map<String, Integer> wordCounts = new HashMap<>();
            BufferedReader reader = new BufferedReader(new FileReader(fileName));
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.trim().split("\\s+");
                if (parts.length == 2) {
                    String word = parts[0].toLowerCase();
                    int count = Integer.parseInt(parts[1]);
                    wordCounts.put(word, count);
                    vocabSet.add(word);
                }
            }
            reader.close();
            allDocWordCounts.add(wordCounts);
        }

        List<String> vocabulary = new ArrayList<>(vocabSet);
        Collections.sort(vocabulary);

        int noOfTokens = vocabulary.size();
        System.out.println("\nVocabulary: " + vocabulary);

        int[][] docMatrix = new int[noOfDocs][noOfTokens];

        for (int docIndex = 0; docIndex < noOfDocs; docIndex++) {
            Map<String, Integer> wordCounts = allDocWordCounts.get(docIndex);
            for (int tokenIndex = 0; tokenIndex < noOfTokens; tokenIndex++) {
                String token = vocabulary.get(tokenIndex);
                docMatrix[docIndex][tokenIndex] = wordCounts.getOrDefault(token, 0);
            }
        }

        System.out.println("\nDocument-Token Matrix:");
        for (int i = 0; i < noOfDocs; i++) {
            System.out.println("Doc " + (i + 1) + ": " + Arrays.toString(docMatrix[i]));
        }

        BufferedReader stdInput = new BufferedReader(new InputStreamReader(System.in));

        System.out.println("\nEnter threshold:");
        float threshold = Float.parseFloat(stdInput.readLine());

        while (true) {
            System.out.println("\nChoose clustering algorithm:");
            System.out.println("1. Single Pass Algorithm (Disjoint Clustering)");
            System.out.println("2. Single Pass Algorithm (Overlapping Clustering)");
            System.out.println("3. Exit");
            System.out.print("Enter your choice: ");
            int choice = Integer.parseInt(stdInput.readLine());
            switch (choice) {
                case 1 ->                     {
                        System.out.println("\nRunning Single Pass Algorithm (Disjoint Clustering):");
                        int[][] clusters = SinglePassAlgorithmDisjoint(noOfDocs, noOfTokens, docMatrix, threshold);
                    }
                case 2 ->                     {
                        System.out.println("\nRunning Single Pass Algorithm (Overlapping Clustering):");
                        int[][] clusters = SinglePassAlgorithmOverlapping(noOfDocs, noOfTokens, docMatrix, threshold);
                        printClusters(clusters);
                    }
                case 3 -> {
                    System.out.println("Exiting program.");
                    return;
                }
                default -> System.out.println("Invalid choice");
            }
        }

    }

    public static int[][] SinglePassAlgorithmDisjoint(int noOfDocs, int noOfTokens, int[][] docMatrix, float threshold) {

        int[][] cluster = new int[noOfDocs][noOfDocs + 1];
        ArrayList<Float[]> clusterRepresentative = new ArrayList<>();

        cluster[0][0] = 1;
        cluster[0][1] = 0;
        int noOfClusters = 1;

        Float[] firstDoc = convertToFloat(docMatrix[0]);
        clusterRepresentative.add(firstDoc);

        for (int i = 1; i < noOfDocs; i++) {
            float max = -1;
            int clusterId = -1;

            for (int j = 0; j < noOfClusters; j++) {
                float similarity = calculateCosineSimilarity(convertToFloat(docMatrix[i]), clusterRepresentative.get(j));

                if (similarity > threshold && similarity > max) {
                    max = similarity;
                    clusterId = j;
                }
            }

            if (max == -1) {
                cluster[noOfClusters][0] = 1;
                cluster[noOfClusters][1] = i;
                clusterRepresentative.add(convertToFloat(docMatrix[i]));
                noOfClusters++;
            } else {
                cluster[clusterId][0]++;
                int index = cluster[clusterId][0];
                cluster[clusterId][index] = i;

                clusterRepresentative.set(clusterId, calculateClusterRepresentative(cluster[clusterId], docMatrix, noOfTokens));
            }
        }

        for (int i = 0; i < noOfClusters; i++) {
            System.out.print("\nCluster " + i + ": ");
            for (int j = 1; j <= cluster[i][0]; ++j) {
                System.out.print("Doc" + cluster[i][j] + " ");
            }
        }

        return cluster;
    }

    public static int[][] SinglePassAlgorithmOverlapping(int noOfDocs, int noOfTokens, int[][] docMatrix, float threshold) {
        List<List<Integer>> clusters = new ArrayList<>();
        List<Integer> representatives = new ArrayList<>();

        List<Integer> firstCluster = new ArrayList<>();
        firstCluster.add(0);
        clusters.add(firstCluster);
        representatives.add(0);

        for (int i = 1; i < noOfDocs; i++) {
            boolean assigned = false;
            Float[] docVec = convertToFloat(docMatrix[i]);

            for (int j = 0; j < clusters.size(); j++) {
                int repDocIdx = representatives.get(j);
                Float[] repVec = convertToFloat(docMatrix[repDocIdx]);

                Float similarity = calculateCosineSimilarity(docVec, repVec);

                if (similarity >= threshold) {
                    clusters.get(j).add(i);
                    assigned = true;
                }
            }

            if (!assigned) {
                List<Integer> newCluster = new ArrayList<>();
                newCluster.add(i);
                clusters.add(newCluster);
                representatives.add(i);
            }
        }

        int[][] finalClusters = new int[clusters.size()][];
        for (int i = 0; i < clusters.size(); i++) {
            List<Integer> cluster = clusters.get(i);
            finalClusters[i] = new int[cluster.size()];
            for (int j = 0; j < cluster.size(); j++) {
                finalClusters[i][j] = cluster.get(j);
            }
        }

        return finalClusters;
    }
    
    private static void printClusters(int[][] clusters) {
        for (int i = 0; i < clusters.length; i++) {
            System.out.print("Cluster " + i + ": ");
            for (int j = 0; j < clusters[i].length; j++) {
                System.out.print("Doc" + clusters[i][j] + " ");
            }
            System.out.println();
        }
    }

    private static Float[] convertToFloat(int[] arr) {

        int size = arr.length;
        Float[] floatArr = new Float[size];

        for (int i = 0; i < size; i++) {
            floatArr[i] = (float) arr[i];
        }

        return floatArr;
    }

    private static Float calculateCosineSimilarity(Float[] vec1, Float[] vec2) {

        float dotProduct = 0f;
        float normVec1 = 0f;
        float normVec2 = 0f;

        for (int i = 0; i < vec1.length; i++) {
            dotProduct += vec1[i] * vec2[i];
            normVec1 += vec1[i] * vec1[i];
            normVec2 += vec2[i] * vec2[i];
        }

        if (normVec1 == 0 || normVec2 == 0) {
            return 0f;
        }
        return dotProduct / ((float) (Math.sqrt(normVec1) * Math.sqrt(normVec2)));
    }

    private static Float[] calculateClusterRepresentative(int[] cluster, int[][] input, int noOFTokens) {
        Float[] answer = new Float[noOFTokens];
        for (int i = 0; i < noOFTokens; i++) {
            answer[i] = Float.valueOf("0");
        }

        for (int i = 1; i <= cluster[0]; ++i) {
            for (int j = 0; j < noOFTokens; j++) {
                answer[j] += input[cluster[i]][j];
            }
        }

        for (int i = 0; i < noOFTokens; i++) {
            answer[i] /= cluster[0];
        }
        return answer;
    }
}


PS D:\BE-IT-Practicals\Information_Retrieval\Assignement 2> java .\SinglePassAlgorithm.java

Vocabulary: [apple, banana, grape, lemon, orange]

Document-Token Matrix:
Doc 1: [2, 1, 0, 0, 0]
Doc 2: [0, 3, 1, 0, 0]
Doc 3: [0, 0, 2, 0, 1]
Doc 4: [3, 2, 0, 1, 0]

Enter threshold:
0.50

Choose clustering algorithm:
1. Single Pass Algorithm (Disjoint Clustering)
2. Single Pass Algorithm (Overlapping Clustering)
3. Exit
Enter your choice: 1

Running Single Pass Algorithm (Disjoint Clustering):

Cluster 0: Doc0 Doc3
Cluster 1: Doc1
Cluster 2: Doc2
Choose clustering algorithm:
1. Single Pass Algorithm (Disjoint Clustering)
2. Single Pass Algorithm (Overlapping Clustering)
3. Exit
Enter your choice: 2

Running Single Pass Algorithm (Overlapping Clustering):
Cluster 0: Doc0 Doc3
Cluster 1: Doc1 Doc3
Cluster 2: Doc2

Choose clustering algorithm:
1. Single Pass Algorithm (Disjoint Clustering)
2. Single Pass Algorithm (Overlapping Clustering)
3. Exit
Enter your choice: 3
Exiting program.
PS D:\BE-IT-Practicals\Information_Retrieval\Assignement 2> 