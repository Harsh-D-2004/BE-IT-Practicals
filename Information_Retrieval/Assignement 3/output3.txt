INPUT:

DOC1
Apple and orange are my favorite fruits. 
I like to eat apple in the morning and orange at night. 
Mango is also tasty, but apple is the best!

DOC2
Banana is a good source of energy. 
Mango and banana make a great smoothie. 
Orange juice with banana is refreshing.

DOC3
Apple and mango grow well in tropical regions. 
Banana trees are found in many countries. 
Orange is rich in vitamin C and very healthy.

CODE:

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.stream.Collectors;

public class isr3 {

    private static final Map<String, Map<String, List<Integer>>> invertedIndex = new HashMap<>();
    private static final Set<String> stopwords = new HashSet<>(Arrays.asList(
        "i", "am", "the", "and", "or", "but", "if", "is", "are", "was", "were",
        "in", "on", "at", "to", "from", "by", "with", "about", "as", "for", "of", "draw"
    ));

    private static final String OUTPUT_FILE = "output.txt";
    private static final String INDEX_FILE = "index.txt";

    /** Normalize a word: remove non-alphanumeric and lowercase */
    private static String normalize(String word) {
        return word.chars()
                .filter(Character::isLetterOrDigit)
                .mapToObj(c -> String.valueOf((char) c))
                .collect(Collectors.joining())
                .toLowerCase();
    }

    /** Extracts filename from path */
    private static String getBaseFilename(String filepath) {
        return Paths.get(filepath).getFileName().toString();
    }

    /** Build inverted index from a list of files */
    private static void buildIndex(List<String> filenames) {
        for (String filename : filenames) {
            try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
                String baseFilename = getBaseFilename(filename);
                String line;
                int position = 0;

                while ((line = reader.readLine()) != null) {
                    for (String word : line.split("\\s+")) {
                        String cleaned = normalize(word);
                        if (cleaned.isEmpty() || stopwords.contains(cleaned)) continue;

                        position++;
                        invertedIndex
                                .computeIfAbsent(cleaned, k -> new HashMap<>())
                                .computeIfAbsent(baseFilename, k -> new ArrayList<>())
                                .add(position);
                    }
                }
            } catch (IOException e) {
                System.err.println("Could not open file: " + filename);
            }
        }
    }

    /** Format postings for a word */
    private static String formatPosting(String word, Set<String> allowedDocs) {
        Map<String, List<Integer>> postings = invertedIndex.get(word);
        if (postings == null) return word + " -> [ ]";

        List<String> docs = new ArrayList<>();
        for (String doc : postings.keySet()) {
            if (allowedDocs == null || allowedDocs.contains(doc)) {
                docs.add(doc);
            }
        }
        if (docs.isEmpty()) return word + " -> [ ]";

        Collections.sort(docs);
        StringBuilder sb = new StringBuilder(word + " -> ");
        for (int i = 0; i < docs.size(); i++) {
            String doc = docs.get(i);
            sb.append(doc).append("[").append(
                postings.get(doc).stream()
                        .map(String::valueOf)
                        .collect(Collectors.joining(", "))
            ).append("]");
            if (i < docs.size() - 1) sb.append(" -> ");
        }
        return sb.toString();
    }

    /** Format document set */
    private static String formatDocSet(Set<String> docs) {
        if (docs.isEmpty()) return "[]";
        List<String> sorted = new ArrayList<>(docs);
        Collections.sort(sorted);
        return "[" + String.join(", ", sorted) + "]";
    }

    /** Log text to console and output file */
    private static void log(String text, BufferedWriter writer) throws IOException {
        System.out.println(text);
        writer.write(text);
        writer.newLine();
    }

    /** Handle AND / OR boolean query */
    private static void handleBoolean(String w1, String w2, String op, BufferedWriter writer) throws IOException {
        Set<String> docs1 = new HashSet<>(Optional.ofNullable(invertedIndex.get(w1))
                .map(Map::keySet).orElse(Collections.emptySet()));

        Set<String> docs2 = new HashSet<>(Optional.ofNullable(invertedIndex.get(w2))
                .map(Map::keySet).orElse(Collections.emptySet()));

        Set<String> result = new HashSet<>();
        if (op.equals("AND")) {
            for (String doc : docs1) {
                if (docs2.contains(doc)) result.add(doc);
            }
        } else {
            result.addAll(docs1);
            result.addAll(docs2);
        }

        log(w1 + " " + op + " " + w2 + " -> " + formatDocSet(result), writer);
        log(formatPosting(w1, result), writer);
        log(formatPosting(w2, result), writer);
    }

    private static void processQuery(String query, BufferedWriter writer) throws IOException {
        String q = query.toLowerCase();
        if (q.contains(" and ")) {
            String[] parts = q.split(" and ");
            handleBoolean(parts[0], parts[1], "AND", writer);
        } else if (q.contains(" or ")) {
            String[] parts = q.split(" or ");
            handleBoolean(parts[0], parts[1], "OR", writer);
        } else {
            log(formatPosting(q, null), writer);
        }
    }

    private static void saveIndex() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(INDEX_FILE))) {
            for (String word : invertedIndex.keySet()) {
                writer.write(word + " -> ");
                boolean firstDoc = true;
                for (Map.Entry<String, List<Integer>> entry : invertedIndex.get(word).entrySet()) {
                    if (!firstDoc) writer.write(" -> ");
                    writer.write(entry.getKey() + "[" + entry.getValue().stream()
                            .map(String::valueOf)
                            .collect(Collectors.joining(", ")) + "]");
                    firstDoc = false;
                }
                writer.newLine();
            }
        } catch (IOException e) {
            System.err.println("Error saving index: " + e.getMessage());
        }
    }

    public static void main(String[] args) {
        List<String> filenames = Arrays.asList("Docs/doc1.txt", "Docs/doc2.txt", "Docs/doc3.txt");

        buildIndex(filenames);

        saveIndex();

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(OUTPUT_FILE));
             Scanner scanner = new Scanner(System.in)) {

            while (true) {
                System.out.print("Enter a query : ");
                String query = scanner.nextLine().trim();
                if (query.equalsIgnoreCase("exit")) break;
                processQuery(query, writer);
            }
        } catch (IOException e) {
            System.err.println("Error writing output: " + e.getMessage());
        }
    }
}


INDEX FILE
very -> doc3.txt[16]
regions -> doc3.txt[6]
best -> doc1.txt[16]
source -> doc2.txt[4]
trees -> doc3.txt[8]
good -> doc2.txt[3]
apple -> doc3.txt[1] -> doc1.txt[1, 8, 15]
found -> doc3.txt[9]
fruits -> doc1.txt[5]
eat -> doc1.txt[7]
make -> doc2.txt[8]
energy -> doc2.txt[5]
smoothie -> doc2.txt[11]
banana -> doc3.txt[7] -> doc2.txt[1, 7, 14]
grow -> doc3.txt[3]
like -> doc1.txt[6]
night -> doc1.txt[11]
rich -> doc3.txt[13]
also -> doc1.txt[13]
countries -> doc3.txt[11]
many -> doc3.txt[10]
juice -> doc2.txt[13]
my -> doc1.txt[3]
great -> doc2.txt[10]
vitamin -> doc3.txt[14]
mango -> doc3.txt[2] -> doc1.txt[12] -> doc2.txt[6]
morning -> doc1.txt[9]
tropical -> doc3.txt[5]
orange -> doc3.txt[12] -> doc1.txt[2, 10] -> doc2.txt[12]
healthy -> doc3.txt[17]
refreshing -> doc2.txt[15]
well -> doc3.txt[4]
tasty -> doc1.txt[14]
favorite -> doc1.txt[4]


OUTPUT
PS D:\BE-IT-Practicals\Information_Retrieval\Assignement 3> java isr3.java
Enter a query : Banana
banana -> doc2.txt[1, 7, 14] -> doc3.txt[7]
Enter a query : Apple
apple -> doc1.txt[1, 8, 15] -> doc3.txt[1]
Enter a query : exit
PS D:\BE-IT-Practicals\Information_Retrieval\Assignement 3> 